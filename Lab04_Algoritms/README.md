# Лабораторна робота №4 — Нелінійні списки (дерева) та Бінарні дерева пошуку (BST)

> C++17 • CMake • Консольні застосунки `lab04_01` (звичайне бінарне дерево) і `lab04_02` (BST)

## Зміст
- [Опис](#опис)
- [Структура проєкту](#структура-проєкту)
- [Вимоги](#вимоги)
- [Збірка](#збірка)
- [Запуск](#запуск)
  - [Частина 1 — звичайне бінарне дерево (`lab04_01`)](#частина-1--звичайне-бінарне-дерево-lab04_01)
  - [Частина 2 — BST (`lab04_02`)](#частина-2--bst-lab04_02)
- [Алгоритми та API](#алгоритми-та-api)
- [Приклади](#приклади)
- [Візуалізація дерева](#візуалізація-дерева)
- [Тестування](#тестування)
- [Поширені питання](#поширені-питання)
- [Ліцензія](#ліцензія)

---

## Опис
Репозиторій містить реалізацію:
1. **Звичайного бінарного дерева** фіксованого розміру `n` з обходами `Preorder`, `Inorder`, `Postorder` та функцією красивого виводу.
2. **Бінарного дерева пошуку (BST)** з операціями пошуку, вставки, видалення, мінімуму/максимуму, а також знаходження наступника і попередника.

У Частині 1 значення **не впливають** на форму дерева: ключі розкладаються у порядку побудови.  
У Частині 2 виконується інваріант BST: *ліворуч — менші, праворуч — більші, дублікатів немає.*

## Структура проєкту
```
CMakeLists.txt
include/
  Tree.h
src/
  Tree.cpp
  Lab_04_01.cpp   # частина 1: створення/візуалізація/обходи
  Lab_04_02.cpp   # частина 2 (BST): пошук/вставка/видалення/Min/Max/Succ/Pred
```

## Вимоги
- C++17 (g++/clang/MSVC)
- CMake ≥ 3.15
- Будь-яка ОС (Windows / Linux / macOS)

## Збірка
```bash
# У корені репозиторію
cmake -S . -B build
cmake --build build -j
```

Артефакти з’являться у `build/`:
- `build/lab04_01`
- `build/lab04_02`

## Запуск

### Частина 1 — звичайне бінарне дерево (`lab04_01`)
Функціонал: `CreateTree`, `ShowTree`, `Preorder`, `Inorder`, `Postorder`, `FreeTree`.

```bash
./build/lab04_01
# Далі в меню:
# 1) CreateTree → ввести n, далі ключі (або автозаповнення 1..n)
# 2) ShowTree → побачити дерево
# 3–5) Обходи → подивитися порядок відвідування
```

> **Примітка.** У Частині 1 `Inorder` не гарантує сортування, бо це не BST.

### Частина 2 — BST (`lab04_02`)
Функціонал: `Search`, `Insert`, `Delete`, `Minimum`, `Maximum`, `Successor`, `Predecessor`, `InOrder`.

```bash
./build/lab04_02
# У меню:
# Insert → додати ключ
# Search → пошук ключа
# Delete → видалення вузла
# InOrder → переконатися, що вивід відсортований
# Min/Max/Succ/Pred → допоміжні операції
```

## Алгоритми та API

### Обходи (DFS)
- **Preorder**: вузол → ліво → право  
- **Inorder**: ліво → вузол → право (у BST дає відсортовані ключі)  
- **Postorder**: ліво → право → вузол

### BST-операції
- `SearchNodeBST(root, key)` — спуск вліво/вправо, поки не знайдемо або `nullptr`.  
- `InsertNodeBST(root&, key)` — як пошук; у місці `nullptr` створюється вузол.  
- `MinimumNodeBST(root)` / `MaximumNodeBST(root)` — найлівіше / найправіше.  
- `SuccessorNodeBST(x)` — наступник: **мінімум у правому піддереві**, або підйом до предка, де `x` лежить ліворуч.  
- `PredecessorNodeBST(x)` — попередник: **максимум у лівому піддереві**, або підйом до предка, де `x` лежить праворуч.  
- `DeleteNodeBST(root&, del)` — три випадки:
  1) 0 дітей — від’єднати вузол;
  2) 1 дитина — підвісити дитину замість вузла;
  3) 2 дитини — **скопіювати ключ наступника** в вузол і видалити наступника (у нього ≤ 1 дитина).

Усі операції — `O(h)` часу, де `h` — висота дерева.

## Приклади

### 1) Частина 1: `n = 6`, автозаповнення 1..6
Очікувані обходи:
- Preorder: `1 2 3 4 5 6`
- Inorder: `3 2 4 1 6 5`
- Postorder: `3 4 2 6 5 1`

### 2) Частина 2: базовий тест BST
Вставки: `50 30 70 20 40 60 90`  
- InOrder: `20 30 40 50 60 70 90`  
- Successor(50) → `60`, Predecessor(50) → `45` (якщо додати 45), Successor(90) → `nullptr`  
- Delete(50) → корінь стає `60`, InOrder зберігається відсортованим

## Візуалізація дерева
Використовується «перекинутий» друк: **праві гілки зверху**, **ліві — знизу**.  
Якщо у терміналі замість лінійок `┌ └ │` бачите квадратики, увімкніть UTF‑8 або перейдіть на ASCII-варіант.

ASCII-шаблони:
```
┌── → /--
└── → \--
│   → |  
```

## Тестування
Швидкі перевірки:
- **BST InOrder** має давати **строго зростаючу** послідовність без дублікатів.
- Для `Successor/Predecessor` протестуйте кілька випадків: вузол із правим/лівим піддеревом і крайні значення (мінімум/максимум).
- Для `Delete`: листок → одна дитина → дві дитини (через наступника).

## Поширені питання
**Чому Inorder у Частині 1 не відсортований?**  
Бо дерево не BST: форма задається розбиттям `n_left/n_right`, а не порівняннями ключів.

**Чому відображення «перевернуте»?**  
Це зручний спосіб показати праві гілки зверху, ліві знизу. Читати треба зверху вниз.

**Куди поділись «скобки» біля кореня?**  
Для кореня конектор не друкується навмисно, щоб гілки дітей починались поруч із коренем.

## Ліцензія
Навчальне використання. За потреби можна встановити **MIT** або іншу навчальну ліцензію.
